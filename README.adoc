= Goal Dependency Thesis Project

This project uses AI to efficiently accomplish top level goals in an environment with strict goal dependency hierarchies.


== Requirements

- Python 3
    If you plan on using Tensorflow with GPU support, this must be Python 3.5

- Graphviz
    Graphviz has two components. There's a pip package that's noted below,
    but also has an https://www.graphviz.org/Download.php[executable] that you must have in your path in order for some components of this project to work.

- Tensorflow (with GPU support)
    For now, this is optional since no part of the main system uses Tensorflow

- Minecraft
    Optional. The current system doesn't interface with Minecraft but will in the near future

- Minutor
    Optional. This allows you to capture layers of a Minecraft world. There are sample layers in `resources/2D` so you can use those if you don't want to capture your own

=== pip Requirements

`$pip install pillow pyautogui graphviz`

== Terminology/Functionality/Architecture Description

The purpose of this project is to use AI to make goal based decisions in an environment where top level goals have subgoals with strict dependencies.
That is to say that a goal can't be completed or even approached before its subgoals have been completed.
Additionally, in this environment, there may be more than one way to achieve a goal, so there are potential decisions between different parallel subgoals.
In the context of this project, the environment is a game environment for the game Minecraft.
For the purposes of this project, the goals will be represented by a PlayerState (PS) which represents the state of the player's inventory, buffs, and the current item under crosshairs.
Nearly all goals in the game require a certain PS before they can be approached.
For example, crafting a certain tool might require a set of resources to be present in the player's inventory.
This means the goal of the tool can be decomposed into subgoals for each of those resources required to be in the player's inventory.
Similarly, if a resource needs to be harvested, a specific tool might be required along with having a specific block in front of the player.
This would mean there would be subgoals involving both acquiring the tool AND moving into a position where the block is in front of the player.

As described above a goal might have multiple subgoals. Additionally, there may be multiple ways to approach a subgoal.
Due to this, a goal can be represented with a PlayerStateTarget (PST) which breaks a PS goal into attributes.
This would mean that if two different resources are required, then they would be split into separate PS's contained by the PST.
As previously mentioned, there might be multiple ways to complete one of these attribute PS's.
For that reason, each attribute in the PST has a set of one or more PlayerStateSolutions (PSS) which represent a single approach to complete that respective attribute PS.
For example, if there were two tools that could harvest one unit of a specific resource, both would be added as PSS for that resource's corresponding attribute PS in the PST.

With this environment, there is a set of known actions that have required inputs and expected outputs.
The actions are contained by an ActionTarget (AT) which has a prerequisite PS and a result PS, and is connected to a PSS to act as an executable task.
An PST is created to wrap the AT's prerequisite PS. The AT may not have a prerequisite, which is why all leaf nodes on the dependency tree are AT's.

For the previous example, what if the output of the PSS using the first tool to harvest the resource was more than the required amount to satisfy the attribute PS corresponding to that PSS?
This would create excess materials. To avoid this, the PSS can pool identical attribute PS's from PST's on the same tree layer. This means PSS's may have multiple parents.
In the reverse situation, if one execution of the PSS's respective AT wouldn't satisfy the attribute PS referenced by the PSS, then the PSS will hold enough children AT's to satisfy the requirement.

During each step during execution, a set of cost scalars are generated (more on this later) which correlate with each known action within the environment.
These scalars are passed to each leaf AT node on the tree, then these costs are propagated upward until the topmost PST node.
Starting from the topmost PST node, the cheapest attached PSS is picked, followed by that PSS's first AT, followed (recursively) by the AT's child PST's cheapest attached PSS.
Once a leaf AT is selected, it is executed. If it completes this step, it propagates its returned PS upward to its parent PSS, and removes itself from the tree.
If its parent PSS doesn't complete, that PSS's parent PST updates the competing PSS's with the lowered PS requirements.
In turn, that PSS and its PST parent propagate upward if they have no children and are therefore complete.

'''

Since the system operates within a game without a direct Python interface, operating within the game requires a substantial amount of world modeling.
Actions in the game are generally categorized into the following areas

* harvesting resources
* locating and moving to resources
* crafting resources

Crafting and harvesting resources require certain existing inventory states and player positioning relative to certain game objects, but aren't very involved given those requirements are fulfilled.
This means they can be completed with simple input scripts to move the mouse to certain locations within the game, given the player's inventory and positioning is known.
However, locating and moving to resources requires substantially more knowledge about the game world.
Ideally, this would be handled by an AI subsystem which utilized computer vision to extract dimensional data and identify the locations of resources.
Unfortunately, this proved to be unrealistic after a training set of over 6000 labeled images was manually generated only to yield extremely unreliable CV models.
The alternative to this would be to directly extract dimensional data from game files but this isn't possible, or at least isn't reasonable for this scope of project.
Due to these factors, the following world models are necessary.

1) The 2D world Model
In order to simplify the world, the test environments for the project are flatted to be essentially 2D. In addition, `gameWorld2d.py` holds a representation of the game world
based on a set of layers of the world, and tracks the player's position during execution.
This gives the utility of locating game objects as well as pathfinding to those objects.

2) The Inventory Model
The player's inventory must be tracked and managed during execution in order for scripts to target the right positions in the player's inventory.
`inventoryManager.py` contains an inventory manager that tracks the expected state of the player's inventory throughout execution.
Whenever a player takes an action that would affect the player's inventory, the actual inventory needs to be cross referenced with the expected inventory.
Luckily, the game can be temporarily paused and unpaused to save the player's actual inventory to a file which can be parsed to line up against the expected inventory.

3) The Player Memory Model
Some knowledge that the player needs doesn't fit within the abstraction level of PS.
For example, during a 'locate and move to' action, the player initially establishes the ideal path to a game object.
The player needs to know the path the establish initially so execution isn't bogged down by pathfinding each step of the way,
and so heuristics don't falsely throw the player off the ideal path.
Additionally, the it's possible that the player will deviate from that specific goal due to cost scaling (see below) at a later game step, so that previous path needs to be voided from memory at that point.

'''

The AI component of this project comes in the form of the cost scaling each step of execution.
Given environmental inputs, different actions might be more efficient to pursue than others.
Neural networks are employed to take limited environmental inputs and produce scalars (on an interval of (0:1] ) for each known action in the environment.


== Usage

The project has a makefile that can be used for convenience rather than calling the scripts directly.
At this point in the project, none of the scripts are set up to handle CLI calls, so you'll have to edit the last line of the script that actually executes functions.
Primarily, you'll need to edit the last line of `src/main.py` to handle what you want it to do.

Off the bat, you can run

`$make`

which will run a simulation in 2D space to create 10 units of 'stone pickaxe'.
This will display a sequence of images which show the paths to take to complete the task.

Path image color code:

- purple: the path
- black: stone
- green: crafting bench
- blue: tree
- red: unknown

If you're interested in the dependency trees along the way, uncomment line 338 of `main.py`.
Then, run the simulation and look in `trees/`, which will have the dependency tree after every decision.
Tree rendering takes a lot of time so this will slow down the simulation considerably.

Tree color code:

- purple: selected AT node
- green: leaf AT node
- blue: pooled PSS node



== Developer

Copyright 2017 Derek Koleber under MIT License

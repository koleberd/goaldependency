___ uses AI to efficiently accomplish top level goals in an environment with strict goal dependency hierarchies.
Before simulation, ___ breaks down the top level goal's dependencies into a recursive tree of sub-goals, called a dependency tree.
During simulation, ___ uses ML algorithms to analyze world state and player state to select and execute the most efficient sub-goal from the top level goal's dependency tree.
After simulation, ___ trains its ML model to improve its mappings of world/player states to their corresponding sub-goal choices.

--------

learn relations of previously pursued actions on a given action in addition to scales

-randomness of environment
- training data vs simualtion data

-picking choices to minimize other choices in terms of solutions/attributes for PST (can it be done, period)


--------


In depth:
Before simulation, ___ breaks down the top level goal's dependencies into a recursive tree of sub-goals by matching known actions
	(that have known world/player state requirements and results) to goals, and creating sub-goals to represent those action's dependencies, and so on.
	Some actions are pooled to improve tree efficiency, and inefficient or recursive actions are pruned.
During simulation, ___ uses ML algorithms to analyze world state and player state to select and execute the most efficient sub-goal from the top level goal's dependency tree.
After simulation, ___ trains its ML model to improve its mappings of world/player states to their corresponding sub-goal choices,
	and trains the known actions' costs to better match their real costs.



how are multiple branches pursued if they're showing cumulative?
	upwards/downwards propagation of required resources after action completion?
		trim() function recalculates the required playerstate while maintaining overall tree structure
	separation in PST's attributelist based on pools?
	cost in terms of completion of one actionTarget in PSS?

look at sims for scheduling processes

cost with environmental factors in addition to just distance (related to time)
cache use times for individual types so only have to evaluate one individual branch once
	costs held by PSS
branch pruning?
	prune anything without any leaves
how to make scales variable?
which actions can be effectively scaled?
	path finding algorithms


cost learned by clocking action execution times
	for variable time processes like path finding???
		different instances of path finding for different resources types
			finding trees might require different  process than finding stone
		constant times like how long to hit a block are pointless to learn because it depends on tool
			is it really pointless to learn?
				potentially results in overuse of tools/excess harvested resources
cost scalar learned by comparing anticipated time, estimated scaled time, and actual scaled time and adjusting in the direction of (actual scaled time - estimated scaled time)
	learned after task completion

when applying scales, store predicted time in table for each unique action target

	each leaf action target calculates its estimated scaled time
	this is totalled in its parent PSS
	that parent PSS's parent PST's parent AT's parent PSS totals the total cost from all unique child child child PSS's, plus the sum cost from its child AT's

	same as
	select top level PST
	its cost equals the sum of the cheapest child PSS for each attribute
		the child PSS"s cost equals the sum of costs of child AT's plus the sum of all unique PST's
			--how to differentiate between PSTs with common PSS's -> DON'T. POOL TIME = CHILDREN TIME /NUMBER OF PARENTS. THIS WILL BE ACCOUTNED FOR BY EACH PARENT TOUCHING IT AND GIVING THE REDUCED SUM TO ITS PARENT WHERE IT WILL BE EFFECTIVELY UNPOOLED.






pooling viable if pss are on same level of tree and the attribute that they satisify is poolable and ALL their parents have the same name and they have the same name
1. full decomp, prune locations marked, no pooling
2. prune
3. pool


or decomp until actiontarget level, pool, then keep doing decomp until action layer, etc

if this AT's prereq  matches or exceeds this AT's PSS's PST attribute or any parent's, then it should be pruned.






hash functions
action factory
playerstate.clone
playerstatesolution.isTwin

TODO:
	- determine how CV will be incorporated into 2d world
	- will there be CV in the 3d world?
	- find way to match 2d with 3d during/after movement decisions are made in 2d
	- RL vs CV

	Lower priority:
		Dependency tree:
			cross-level pooling
		Runtime AI:
			keep track of sunken costs
			making decision under uncertainty vs under risk
		Testing:
			deeper test level
		Misc:
			look at sims for scheduling processes





Semester 2 goals
- action selection on learned causality relationships
	2 actions are scaled to be 25 and 30, but if I pursue the 30 first, I predict that the previously 25 action will only be 5, making pursuing the 30 first more efficient
- factoring in environmental hazards when weighing decisions
	water might be in the way of a resource, making the seemingly cheap resource more expensive to get to
- can you model a combat system off of this?
	not really, because you'd have to initially spawn a FUCKTON of identical branches for 'kill enemy' or 'stay alive'
		unless branches can be re-spawned dynamically





Working Project Description:
	___ uses AI to efficiently accomplish top level goals in an environment with strict goal dependency hierarchies.
	Before simulation, ___ breaks down the top level goal's dependencies into a recursive tree of sub-goals, called a dependency tree.
	During simulation, ___ uses ML algorithms to analyze world state and player state to select and execute the most efficient sub-goal from the top level goal's dependency tree.
	After simulation, ___ trains its ML model to improve its mappings of world/player states to their corresponding sub-goal choices.


	Add:
	-	learn relations of previously pursued actions on a given action in addition to scales
	- 	randomness of environment
	-	training data vs simualtion data



/gamerule doDaylightCycle false
/time set 6000


NAMING CONVENTIONS:
For class, method, and file names: camel case
For variable names: snake case


additionalnotes
	nomenclature:
		states have values
		attribute have values
		target - something to aim for

	additions to readme/documentation
		how to adapt codebase / project to other areas (as framework)
		justify model vs any other model
			why not written in prolog / other ways to manage dependencies (description of thought rather than implementation)

points in paper:
	start with definitions
	areas for improvement section
		-transformation to goal framework
			-abstracting playerstate
				-modeling priority levels of attributes of one state
	application to other areas/applicability of project to real life
		given extension, ___ could be done
	why is AI helpful
		multiple areas of AI
	why not 3d
		why not cv
	MATH AND FORMULAS AND MORE MATH AND FORMULAS

2d advantages
	- faster sims
	- no issue with handling 3d game
	- avatar vision simplified
	- potentially less domain specific
	- less 3d overhead

todo:
	revamp action selection method to be more abstract
	write decision maker
	rewrite 2d world to allow for better positioning
	write gui
	make list of sections in writeup (index)


reenforcement learning potential?
